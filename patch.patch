diff --git a/.gitpod.yml b/.gitpod.yml
deleted file mode 100644
index 6f4d6d1..0000000
--- a/.gitpod.yml
+++ /dev/null
@@ -1,7 +0,0 @@
-
-tasks:
-  - init: cargo build && make
-    command: cargo watch -x run
-vscode:
-  extensions:
-    - matklad.rust-analyzer
\ No newline at end of file
diff --git a/Cargo.toml b/Cargo.toml
index c97f3c4..d882e7b 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -60,7 +60,8 @@ json_serde = ['serde', 'serde_json']
 state = []
 cookies = ['basic-cookies']
 default = []
-compression = ['libflate', 'brotli2', 'zstd', 'http', 'fly-accept-encoding']
+# compression = ['libflate', 'fly-accept-encoding']
+compression = ['libflate']
 
 [dependencies]
 threadpool = "1.7.1"
@@ -71,11 +72,8 @@ hatter = { version = "0.1.1", optional = true }
 horrorshow = { version = "0.8.3", optional = true }
 serde = { version = "1", optional = true }
 serde_json = { version = "1", optional = true }
-libflate = { version = "1.1.1", optional = true } #gzip and deflate
-fly-accept-encoding = { version = "0.2.0-alpha.5", optional = true } 
-brotli2 = { version = "*", optional = true }
-zstd = { version = "*", optional = true }
-http = { version = "*", optional = true }
+libflate = { version = "1.1.1", optional = true }
+# fly-accept-encoding = { version = "0.2.0-alpha.5", optional = true }
 
 [dev-dependencies]
 criterion = { version = "0.3", features = ["html_reports"] }
diff --git a/src/request.rs b/src/request.rs
index c5b8efe..494f039 100644
--- a/src/request.rs
+++ b/src/request.rs
@@ -1,5 +1,3 @@
-#[cfg(feature = "compression")]
-use fly_accept_encoding::Encoding;
 use std::net::TcpStream;
 use {
     crate::{http_parser, util, Error, Result, TypeCache},
@@ -71,7 +69,7 @@ pub struct Request {
     cookies: Vec<(String, String)>,
 
     #[cfg(feature = "compression")]
-    compression: Encoding,
+    gzip: bool,
 }
 
 impl fmt::Debug for Request {
@@ -124,7 +122,7 @@ impl Request {
             #[cfg(feature = "cookies")]
             cookies: vec![],
             #[cfg(feature = "compression")]
-            compression: Encoding::Identity,
+            gzip: false,
         }
     }
 
@@ -356,27 +354,14 @@ impl Request {
             .next()
     }
     #[cfg(feature = "compression")]
-    /// Return the compression type from accept-encoding header
-    pub fn compression(&self) -> Option<crate::response::VialEncoding> {
-        use crate::response::VialEncoding;
-
+    /// Return whether the request has a Content-Encoding header containing "gzip"
+    pub fn gzip(&self) -> bool {
         if let Some(content_encoding) = self.header("Accept-Encoding") {
-            let mut headers = http::header::HeaderMap::new();
-            headers.insert(
-                http::header::ACCEPT_ENCODING,
-                http::header::HeaderValue::from_str(&content_encoding).unwrap(),
-            );
-            if let Ok(Some(compression)) = fly_accept_encoding::parse(&headers) {
-                return match compression {
-                    Encoding::Gzip => Some(VialEncoding::Gzip),
-                    Encoding::Deflate => Some(VialEncoding::Deflate),
-                    Encoding::Brotli => Some(VialEncoding::Brotli),
-                    Encoding::Zstd => Some(VialEncoding::Zstd),
-                    Encoding::Identity => None,
-                };
+            if content_encoding.into_owned().contains("gzip") {
+                return true;
             }
         }
-        None
+        false
     }
 
     /// Request's `cache()` lives for only a single Request, but can
diff --git a/src/response.rs b/src/response.rs
index c97e58c..ff124ae 100644
--- a/src/response.rs
+++ b/src/response.rs
@@ -10,14 +10,7 @@ use {
         io::{self, BufReader},
     },
 };
-/// Encoding. Internal enum to avoid importing content encoding package w/o feature
-pub enum VialEncoding {
-    Gzip,
-    Deflate,
-    Brotli,
-    Zstd,
-    Identity,
-}
+
 /// Response Body. Will be either a `String` or `io::Read`, like from
 /// a File.
 enum Body {
@@ -386,7 +379,7 @@ impl Response {
     }
 
     /// Writes this response to a stream.
-    pub fn write<W: io::Write>(mut self, mut w: W, encoding: &Option<VialEncoding>) -> Result<()> {
+    pub fn write<W: io::Write>(mut self, mut w: W, _gzip: bool) -> Result<()> {
         // gross - move into print_headers or something
         let mut header = format!(
             "HTTP/1.1 {} OK\r\nServer: ~ vial {} ~\r\nDate: {}\r\nConnection: close\r\n",
@@ -401,53 +394,15 @@ impl Response {
             Body::Reader(mut reader) => {
                 #[cfg(feature = "compression")]
                 {
-                    match encoding {
-                        Some(encoding) => match encoding {
-                            VialEncoding::Gzip => {
-                                let mut vec = vec![];
-                                if reader.read_to_end(&mut vec).is_ok() {
-                                    body.write_all(
-                                        &libflate::gzip::Encoder::new(vec)
-                                            .unwrap()
-                                            .finish()
-                                            .into_result()
-                                            .unwrap(),
-                                    )?;
-                                }
-                            }
-                            VialEncoding::Deflate => {
-                                let mut vec = vec![];
-                                if reader.read_to_end(&mut vec).is_ok() {
-                                    body.write_all(
-                                        &libflate::deflate::Encoder::new(vec)
-                                            .finish()
-                                            .into_result()
-                                            .unwrap(),
-                                    )?;
-                                }
-                            }
-                            VialEncoding::Brotli => {
-                                io::copy(
-                                    &mut brotli2::read::BrotliEncoder::new(reader, 6),
-                                    &mut body,
-                                )?;
-                            }
-                            VialEncoding::Zstd => {
-                                let mut vec = vec![];
-                                if reader.read_to_end(&mut vec).is_ok() {
-                                    let zstd = zstd::stream::write::Encoder::new(vec, 3)
-                                        .unwrap()
-                                        .finish()
-                                        .unwrap();
-                                    body.write_all(&zstd)?;
-                                    // io::copy(&mut zstd, &mut body)?;
-                                }
-                            }
-                            VialEncoding::Identity => todo!(),
-                        },
-                        None => {
-                            io::copy(&mut reader, &mut body)?;
+                    if _gzip {
+                        let mut vec = vec![];
+                        if reader.read_to_end(&mut vec).is_ok(){
+                            body.write_all(
+                                &Encoder::new(vec).unwrap().finish().into_result().unwrap(),
+                            )?;
                         }
+                    } else {
+                        io::copy(&mut reader, &mut body)?;
                     }
                 }
 
@@ -459,21 +414,12 @@ impl Response {
             Body::String(s) => {
                 #[cfg(feature = "compression")]
                 {
-                    match encoding {
-                        Some(encoding) => match encoding {
-                            VialEncoding::Gzip => {
-                                let mut encoder = Encoder::new(vec![]).unwrap();
-                                encoder.write_all(s.as_bytes())?;
-                                body.write_all(&encoder.finish().into_result().unwrap())?;
-                            }
-                            VialEncoding::Deflate => todo!(),
-                            VialEncoding::Brotli => todo!(),
-                            VialEncoding::Zstd => todo!(),
-                            VialEncoding::Identity => todo!(),
-                        },
-                        None => {
-                            body.write_all(s.as_bytes())?;
-                        }
+                    if _gzip {
+                        let mut encoder = Encoder::new(vec![]).unwrap();
+                        encoder.write_all(s.as_bytes())?;
+                        body.write_all(&encoder.finish().into_result().unwrap())?;
+                    } else {
+                        body.write_all(s.as_bytes())?;
                     }
                 }
 
@@ -485,19 +431,9 @@ impl Response {
         self.headers
             .insert("content-length".to_lowercase(), body.len().to_string());
         #[cfg(feature = "compression")]
-        let encoding = match encoding {
-            Some(encoding) => match encoding {
-                VialEncoding::Gzip => Some("gzip"),
-                VialEncoding::Deflate => Some("deflate"),
-                VialEncoding::Brotli => Some("br"),
-                VialEncoding::Zstd => Some("zstd"),
-                VialEncoding::Identity => None,
-            },
-            None => None,
-        };
-        if let Some(encoding_content) = encoding {
+        if _gzip {
             self.headers
-                .insert("content-encoding".to_lowercase(), encoding_content.to_string());
+                .insert("content-encoding".to_lowercase(), "gzip".into());
         }
 
         header.push_str(
diff --git a/src/server.rs b/src/server.rs
index 170018d..66c2888 100644
--- a/src/server.rs
+++ b/src/server.rs
@@ -1,6 +1,4 @@
 use std::time::Duration;
-
-use crate::response::VialEncoding;
 use {
     crate::{asset, Request, Response, Result, Router},
     std::{
@@ -77,15 +75,15 @@ impl Server {
     }
 
     fn write_response(&self, stream: TcpStream, req: Request) -> Result<()> {
-        let compression: Option<VialEncoding> = None;
+        let _gzip = false;
         #[cfg(feature = "compression")]
-        let compression = req.compression();
+        let _gzip = req.gzip();
         let panic_writer = Arc::new(Mutex::new(stream.try_clone()?));
         std::panic::set_hook(Box::new(move |info| {
             let mut res: Vec<u8> = vec![];
             Response::from(500)
                 .with_body(format!("<pre>{}", info))
-                .write(&mut res, &compression)
+                .write(&mut res, _gzip)
                 .unwrap();
 
             println!("ERR 500 {}", String::from_utf8_lossy(&res));
@@ -94,35 +92,35 @@ impl Server {
 
         let method = req.method().to_string();
         let path = req.path().to_string();
-        let (response, encoding) = self.build_response(req);
+        let (response, _gzip) = self.build_response(req);
 
         println!("{} {} {}", method, response.code(), path);
         if response.code() == 500 {
             eprintln!("{}", response.body());
         }
-        response.write(stream, &encoding)
+        response.write(stream, _gzip)
     }
 
-    fn build_response(&self, mut req: Request) -> (Response, Option<VialEncoding>) {
-        let encoding: Option<VialEncoding> = None;
+    fn build_response(&self, mut req: Request) -> (Response, bool) {
+        let _bool = false;
         #[cfg(feature = "compression")]
-        let encoding = req.compression();
+        let _bool = req.gzip();
         //Should this really check for a file on every request? Maybe only if the router doesn't have an action..?
         if asset::exists(req.path()) {
             if let Some(req_etag) = req.header("If-None-Match") {
                 if req_etag == asset::etag(req.path()).as_ref() {
-                    (Response::from(304), encoding)
+                    (Response::from(304), _bool)
                 } else {
-                    (Response::from_asset(req.path()), encoding)
+                    (Response::from_asset(req.path()), _bool)
                 }
             } else {
-                (Response::from_asset(req.path()), encoding)
+                (Response::from_asset(req.path()), _bool)
             }
         } else if let Some(action) = self.router.action_for(&mut req) {
-            let gzip = encoding;
+            let gzip = _bool;
             (action(req), gzip)
         } else {
-            (Response::from(404), encoding)
+            (Response::from(404), _bool)
         }
     }
 }
diff --git a/tests/gzip_test.rs b/tests/gzip_test.rs
index dceb00d..9aeeca5 100644
--- a/tests/gzip_test.rs
+++ b/tests/gzip_test.rs
@@ -1,4 +1,4 @@
-use std::fs;
+use std::{fs};
 use vial::{http_parser::parse, Request};
 
 ////
diff --git a/tests/httparse_test.rs b/tests/httparse_test.rs
index 0487d47..fb1bbb5 100644
--- a/tests/httparse_test.rs
+++ b/tests/httparse_test.rs
@@ -2805,7 +2805,7 @@ test! {
 #[test]
 fn test_request_partial() {
     match parse(b"GET / HTTP/1.1\r\n\r".to_vec()) {
-        Err(Error::ConnectionClosed) => {}
+        Err(Error::ConnectionClosed) => {},
         _ => panic!(),
     }
 }
@@ -2813,7 +2813,7 @@ fn test_request_partial() {
 #[test]
 fn test_request_partial_version() {
     match parse(b"GET / HTTP/1.".to_vec()) {
-        Err(Error::ConnectionClosed) => {}
+        Err(Error::ConnectionClosed) => {},
         _ => panic!(),
     }
 }
